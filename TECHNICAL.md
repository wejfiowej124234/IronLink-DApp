# ğŸ¦€ IronLink DApp - æŠ€æœ¯æ–‡æ¡£

> **é¢å‘å¼€å‘è€…çš„æ·±åº¦æŠ€æœ¯æ–‡æ¡£**  
> å¦‚æœæ‚¨æ˜¯æ™®é€šç”¨æˆ·ï¼Œè¯·æŸ¥çœ‹ [README.md](README.md)

---

## ğŸ“‹ ç›®å½•

- [æŠ€æœ¯æ¦‚è§ˆ](#-æŠ€æœ¯æ¦‚è§ˆ)
- [ä¸ºä»€ä¹ˆé€‰æ‹©Rust](#-ä¸ºä»€ä¹ˆé€‰æ‹©rustå‰ç«¯)
- [Rustæ ¸å¿ƒå®‰å…¨ä¼˜åŠ¿](#-rustæ ¸å¿ƒå®‰å…¨ä¼˜åŠ¿)
- [æ¶æ„è®¾è®¡](#-æ¶æ„è®¾è®¡)
- [æŠ€æœ¯æ ˆ](#-æŠ€æœ¯æ ˆ)
- [å†…å­˜å®‰å…¨å®ç°](#-å†…å­˜å®‰å…¨å®ç°)
- [å¹³å°ç‰¹å®šå®ç°](#-å¹³å°ç‰¹å®šå®ç°)
- [å¼€å‘æŒ‡å—](#-å¼€å‘æŒ‡å—)
- [æµ‹è¯•](#-æµ‹è¯•)
- [æ€§èƒ½åŸºå‡†](#-æ€§èƒ½åŸºå‡†)
- [å®‰å…¨å®¡è®¡](#-å®‰å…¨å®¡è®¡)
- [è´¡çŒ®æŒ‡å—](#-è´¡çŒ®æŒ‡å—)

---

## ğŸ¯ æŠ€æœ¯æ¦‚è§ˆ

### æ ¸å¿ƒå®šä½ (ä¸€å¥è¯)

**IronLink DApp æ˜¯ç”± Rust æ„å»ºçš„è·¨å¹³å°éæ‰˜ç®¡ç§»åŠ¨é’±åŒ…æ¡†æ¶ï¼Œå…·å¤‡å¯å®¡è®¡çš„å†…å­˜å®‰å…¨æ¨¡å‹å’Œä¼ä¸šçº§ API æ”¯æŒã€‚**

---

### ä¸‰å¤§æ ¸å¿ƒç‰¹æ€§

#### 1. ğŸ¦€ Rust å‰åç«¯å…¨æ ˆ

**ç§»åŠ¨ç«¯ (IronLink DApp)**:
- Rust + Dioxus Mobile æ¡†æ¶
- ç¼–è¯‘ä¸ºåŸç”Ÿ iOS/Android åº”ç”¨
- ç¼–è¯‘æ—¶å†…å­˜å®‰å…¨ä¿è¯
- ä¸€æ¬¡ç¼–å†™ï¼ŒåŒå¹³å°éƒ¨ç½²

**åç«¯ (IronCore)**:
- Rust + Axum + Tokio
- ä¼ä¸šçº§ REST API (46+ ç«¯ç‚¹)
- 99.9% SLA é«˜å¯ç”¨ä¿è¯
- 20,000+ è¡Œ Rust ä»£ç 

**ä¼˜åŠ¿**:
- âœ… å‰åç«¯ç±»å‹å…±äº«ï¼Œé›¶æ¥å£é”™è¯¯
- âœ… 95%+ æ ¸å¿ƒé€»è¾‘ä»£ç å¤ç”¨
- âœ… ç»Ÿä¸€çš„ Rust å®‰å…¨æ¨¡å‹
- âœ… æ¯” React Native å¿« 6-10x

---

#### 2. ğŸ”“ éæ‰˜ç®¡æ¶æ„

**å®šä¹‰**: ç”¨æˆ· 100% æŒæ§ç§é’¥ï¼Œé’±åŒ…æä¾›å•†æ— æ³•è®¿é—®èµ„äº§

**å®ç°**:
- âœ… ç§é’¥ç”Ÿæˆ: åœ¨ç”¨æˆ·è®¾å¤‡æœ¬åœ°å®Œæˆ
- âœ… ç§é’¥å­˜å‚¨: Secure Enclave (iOS) / AndroidKeystore (Android)
- âœ… äº¤æ˜“ç­¾å: ç§é’¥æ°¸ä¸ç¦»å¼€è®¾å¤‡
- âœ… åç«¯ç›²ç­¾: IronCore ä»ä¸æ¥è§¦ç§é’¥

**ç”¨æˆ·æƒåˆ©**:
- âœ… 100% èµ„äº§æ§åˆ¶æƒ
- âœ… æ— å®¡æŸ¥é£é™©
- âœ… æ— è´¦æˆ·å†»ç»“é£é™©
- âœ… æ— éœ€ KYC

**ç”¨æˆ·è´£ä»»**:
- âš ï¸ å¿…é¡»è‡ªè¡Œå¤‡ä»½åŠ©è®°è¯
- âš ï¸ å¿…é¡»ä¿æŠ¤è®¾å¤‡å®‰å…¨
- âš ï¸ é—å¤±åŠ©è®°è¯ = æ°¸ä¹…ä¸¢å¤±èµ„äº§

---

#### 3. ğŸ¢ ä¼ä¸šçº§ API (IronCore)

**å®šä½**: æä¾›ä¼ä¸šçº§åŒºå—é“¾åŸºç¡€è®¾æ–½ï¼Œä½†**ä»ä¸æ‰˜ç®¡ç”¨æˆ·èµ„äº§**

**ä¼ä¸šçº§ç‰¹æ€§**:
| ç‰¹æ€§ | å®ç° | ä»·å€¼ |
|------|------|------|
| **é«˜å¯ç”¨æ€§** | 99.9% SLAï¼Œå¤šèŠ‚ç‚¹éƒ¨ç½²ï¼Œè‡ªåŠ¨æ•…éšœè½¬ç§» | 7x24 ç¨³å®šæœåŠ¡ |
| **é«˜æ€§èƒ½** | å¼‚æ­¥ I/Oï¼Œè¿æ¥æ± ï¼ŒRedis ç¼“å­˜ | < 50ms å“åº” |
| **å®‰å…¨é˜²æŠ¤** | JWT è®¤è¯ï¼Œé€Ÿç‡é™åˆ¶ (100 req/min)ï¼ŒDDoS é˜²æŠ¤ | é˜²æ”»å‡» |
| **å¯æ‰©å±•æ€§** | å¾®æœåŠ¡æ¶æ„ï¼Œæ°´å¹³æ‰©å±•ï¼Œè´Ÿè½½å‡è¡¡ | æ”¯æŒç™¾ä¸‡ç”¨æˆ· |
| **ç›‘æ§å‘Šè­¦** | Prometheus + Grafanaï¼Œå®æ—¶ç›‘æ§ | æ•…éšœ < 5 åˆ†é’Ÿå“åº” |
| **å®¡è®¡åˆè§„** | å®Œæ•´æ“ä½œæ—¥å¿—ï¼ŒSOC2 å‡†å¤‡ä¸­ | ä¼ä¸šåˆè§„ |
| **å¤šé“¾æ”¯æŒ** | 5+ åŒºå—é“¾ç»Ÿä¸€æ¥å£ | ä¸€ç«™å¼æœåŠ¡ |

**ä¸ç§é’¥çš„å…³ç³»**:
```
âŒ IronCore ä»ä¸æ¥è§¦:
   - ç”¨æˆ·åŠ©è®°è¯
   - ç”¨æˆ·ç§é’¥
   - ç”¨æˆ·å¯†ç 

âœ… IronCore ä»…å¤„ç†:
   - å…¬é’¥åœ°å€ (æŸ¥è¯¢ç”¨)
   - ç­¾ååçš„äº¤æ˜“ (å¹¿æ’­ç”¨)
   - åŒºå—é“¾æ•°æ®ç´¢å¼•
```

---

### é¡¹ç›®å®šä½

**IronLink DApp** æ˜¯ä¸€ä¸ªé‡‡ç”¨ **100% Rust** æŠ€æœ¯æ ˆå¼€å‘çš„è·¨å¹³å°éæ‰˜ç®¡åŠ å¯†é’±åŒ…ï¼Œé€šè¿‡ **Dioxus** æ¡†æ¶å®ç°ä¸€å¥—ä»£ç ç¼–è¯‘åˆ°å¤šä¸ªå¹³å°ã€‚

### åº”ç”¨åœºæ™¯

IronLink DApp æ—¨åœ¨æˆä¸º**è·¨é“¾èµ„äº§ç®¡ç†çš„å®‰å…¨å…¥å£**ï¼Œæ”¯æŒä»¥å¤ªåŠã€æ¯”ç‰¹å¸ã€Solana ç­‰ä¸»æµåŒºå—é“¾ï¼Œå¹¶é€šè¿‡ Rust å®ç°ã€Œ**åŸç”Ÿå®‰å…¨ + è·¨å¹³å°éƒ¨ç½²**ã€çš„ç»Ÿä¸€ä»£ç æ¶æ„ã€‚

#### æ ¸å¿ƒç›®æ ‡

- âœ… **ä¸ºç»ˆç«¯ç”¨æˆ·æä¾›éæ‰˜ç®¡çš„èµ„äº§ç®¡ç†ä½“éªŒ** - ç”¨æˆ·å®Œå…¨æŒæ§ç§é’¥ï¼Œæ— éœ€ä¿¡ä»»ä¸­å¿ƒåŒ–æœåŠ¡
- âœ… **ä¸ºå¼€å‘è€…æä¾›å¯å¤ç”¨ã€å®‰å…¨ã€å¯å®¡è®¡çš„é’±åŒ…åŸºç¡€æ¡†æ¶** - 95%+ ä»£ç å¤ç”¨ç‡ï¼Œé™ä½å¼€å‘æˆæœ¬
- âœ… **åœ¨ç§»åŠ¨ç«¯ã€Webç«¯ã€æ¡Œé¢ç«¯ä¹‹é—´ä¿æŒ100%é€»è¾‘ä¸€è‡´æ€§** - ä¸€æ¬¡ç¼–å†™ï¼Œå¤šç«¯éƒ¨ç½²

#### å…¸å‹ç”¨æˆ·åœºæ™¯

1. **æ™®é€šç”¨æˆ·** - å®‰å…¨å­˜å‚¨åŠ å¯†èµ„äº§ã€å‘é€æ¥æ”¶äº¤æ˜“ã€æŸ¥çœ‹èµ„äº§ç»„åˆ
2. **DeFi ç”¨æˆ·** - è¿æ¥ DAppã€Swap äº¤æ˜“ã€æµåŠ¨æ€§æŒ–çŸ¿
3. **ä¼ä¸šç”¨æˆ·** - å¤šç­¾é’±åŒ…ã€æ‰¹é‡è½¬è´¦ã€å®¡è®¡è¿½è¸ª
4. **å¼€å‘è€…** - é›†æˆé’±åŒ…åŠŸèƒ½ã€æµ‹è¯• DAppã€å­¦ä¹  Rust ç§»åŠ¨ç«¯å¼€å‘

### å…³é”®æŠ€æœ¯å†³ç­–

| å†³ç­– | é€‰æ‹© | åŸå›  |
|------|------|------|
| **å‰ç«¯æ¡†æ¶** | Dioxus | è·¨å¹³å°ã€ç±»Reactè¯­æ³•ã€åŸç”Ÿæ€§èƒ½ |
| **ç¼–ç¨‹è¯­è¨€** | Rust | å†…å­˜å®‰å…¨ã€é›¶æˆæœ¬æŠ½è±¡ã€å¹¶å‘å®‰å…¨ |
| **UIèŒƒå¼** | å£°æ˜å¼ç»„ä»¶ | æ˜“ç»´æŠ¤ã€æ˜“æµ‹è¯•ã€æ˜“å¤ç”¨ |
| **çŠ¶æ€ç®¡ç†** | Dioxus Signals | å“åº”å¼ã€ç»†ç²’åº¦æ›´æ–° |
| **å¯†ç å­¦** | RustCryptoç”Ÿæ€ | ç»è¿‡å®¡è®¡ã€å¹¿æ³›ä½¿ç”¨ |
| **å¼‚æ­¥è¿è¡Œæ—¶** | Tokio | è¡Œä¸šæ ‡å‡†ã€æ€§èƒ½ä¼˜å¼‚ |

### æ¶æ„åŸåˆ™

1. **å®‰å…¨ç¬¬ä¸€**ï¼šå†…å­˜å®‰å…¨æ˜¯é¦–è¦è®¾è®¡ç›®æ ‡
2. **é›¶ä¿¡ä»»**ï¼šä¸ä¿¡ä»»ç”¨æˆ·è¾“å…¥ã€ä¸ä¿¡ä»»ç½‘ç»œæ•°æ®
3. **ç¡®å®šæ€§**ï¼šå†…å­˜ç®¡ç†ã€é”™è¯¯å¤„ç†éƒ½æ˜¯ç¡®å®šæ€§çš„
4. **å¯å®¡è®¡**ï¼šä»£ç æ¸…æ™°ã€é€»è¾‘ç®€å•ã€æ˜“äºå®¡è®¡
5. **è·¨å¹³å°**ï¼š95%+ä»£ç å¤ç”¨ç‡

---

## ğŸ¦€ ä¸ºä»€ä¹ˆé€‰æ‹©Rustå‰ç«¯ï¼Ÿ

### Rust vs TypeScript å®‰å…¨å¯¹æ¯”

| ç»´åº¦ | TypeScript/JavaScript | Rust | è¯´æ˜ |
|------|----------------------|------|------|
| **å†…å­˜æ¸…ç†** | ä¾èµ– GCï¼Œæ—¶æœºä¸ç¡®å®š | ç¼–è¯‘æ—¶ç¡®å®šæ¸…é›¶ | Zeroize / Drop ç²¾ç¡®æ§åˆ¶ |
| **è°ƒè¯•å™¨æ³„éœ²** | å¯ä» Heap Dump è¯»å– | SecretString å±è”½è°ƒè¯•è¾“å‡º | é˜²æ­¢ Heap åˆ†ææ”»å‡» |
| **å´©æºƒ Dump** | å¯èƒ½ä¿ç•™æ˜æ–‡ | è‡ªåŠ¨æ¸…é›¶ + mlock | å´©æºƒæ—¶ä¸æ³„éœ²ç§é’¥ |
| **æ•°æ®ç«äº‰** | å¤šçº¿ç¨‹ç¯å¢ƒå¸¸è§ | ç¼–è¯‘æœŸæ‹’ç» | Rust å€Ÿç”¨æ£€æŸ¥å™¨é˜²æ­¢ |
| **å†…å­˜äº¤æ¢** | å¯è¢« swap å†™å…¥ç£ç›˜ | mlock é˜²æ­¢ | é˜²æ­¢å†·å¯åŠ¨æ”»å‡» |
| **å¼‚æ­¥å®‰å…¨** | await ä¸­æ˜“å‡ºç°ç«æ€ | ç¼–è¯‘é”™è¯¯é˜²æ­¢æŒé” await | Tokio å®‰å…¨æ¨¡å‹å†…ç½® |
| **ç±»å‹å®‰å…¨** | è¿è¡Œæ—¶ç±»å‹é”™è¯¯ | ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ | é›¶è¿è¡Œæ—¶å¼‚å¸¸ |
| **null å®‰å…¨** | éœ€è¦è¿è¡Œæ—¶æ£€æŸ¥ | Option<T> ç¼–è¯‘æ—¶å¼ºåˆ¶ | æ¶ˆé™¤ null pointer exception |
| **æ•´æ•°æº¢å‡º** | é™é»˜æº¢å‡º | checked_* æ˜¾å¼æ£€æŸ¥ | é˜²æ­¢é‡‘é¢è®¡ç®—é”™è¯¯ |
| **ä¾èµ–å®¡è®¡** | npm audit (å¸¸æœ‰æ¼æ´) | cargo audit (Rust ç¤¾åŒºä¸¥æ ¼) | ä¾›åº”é“¾å®‰å…¨æ€§æ›´é«˜ |

**æ€»ç»“**: Rust åœ¨ç¼–è¯‘æœŸæ¶ˆé™¤ 90%+ çš„å®‰å…¨éšæ‚£ï¼ŒTypeScript åªèƒ½ä¾é è¿è¡Œæ—¶æ£€æŸ¥ã€‚

---

### ä¼ ç»Ÿæ–¹æ¡ˆçš„æŠ€æœ¯é—®é¢˜

#### JavaScript/TypeScriptå†…å­˜æ¨¡å‹

```javascript
// âŒ TypeScript: åƒåœ¾å›æ”¶ä¸å¯æ§
let privateKey = "0x1234...abcd";

// ä½¿ç”¨ç§é’¥...
signTransaction(privateKey);

// å°è¯•æ¸…é™¤ï¼ˆä½†å®é™…æœªæ¸…é™¤ï¼‰
privateKey = null;

// é—®é¢˜ï¼š
// 1. V8å †ä¸­ä»å­˜åœ¨privateKeyå­—ç¬¦ä¸²
// 2. åƒåœ¾å›æ”¶å™¨å†³å®šä½•æ—¶æ¸…ç†ï¼ˆå¯èƒ½æ˜¯ç§’çº§å»¶è¿Ÿï¼‰
// 3. GCæš‚åœæœŸé—´ï¼Œç§é’¥æŒç»­æš´éœ²
// 4. å†…å­˜ç¢ç‰‡å¯èƒ½ä¿ç•™ç§é’¥å‰¯æœ¬
// 5. è°ƒè¯•å™¨å¯ä»¥dumpå †ï¼Œè¯»å–ç§é’¥
```

#### å…·ä½“æ”»å‡»åœºæ™¯

**åœºæ™¯1ï¼šè°ƒè¯•å™¨æ”»å‡»**
```javascript
// å¼€å‘è€…æ— æ„ä¸­åœ¨ç”Ÿäº§ç¯å¢ƒå¯ç”¨äº†source map
let mnemonic = "word1 word2 ... word12";

// æ”»å‡»è€…é€šè¿‡Chrome DevTools:
// 1. æ‰“å¼€Memory â†’ Heap Snapshot
// 2. æœç´¢"word1"
// 3. æ‰¾åˆ°å®Œæ•´åŠ©è®°è¯
// 4. ç›—å–èµ„äº§
```

**åœºæ™¯2ï¼šåº”ç”¨å´©æºƒ**
```javascript
// åº”ç”¨å´©æºƒæ—¶ï¼Œæ“ä½œç³»ç»Ÿç”Ÿæˆå†…å­˜è½¬å‚¨
let privateKey = generateKey();
signTransaction(privateKey);
// æ­¤æ—¶åº”ç”¨å´©æºƒ...

// é—®é¢˜ï¼š
// - privateKeyåœ¨GCæ¸…ç†å‰å´©æºƒ
// - å´©æºƒè½¬å‚¨åŒ…å«privateKeyæ˜æ–‡
// - æ”»å‡»è€…åˆ†æè½¬å‚¨æ–‡ä»¶å³å¯è·å–ç§é’¥
```

### Rustæ–¹æ¡ˆçš„æŠ€æœ¯ä¼˜åŠ¿

#### ç¡®å®šæ€§å†…å­˜æ¸…ç†

```rust
// âœ… Rust: ç¼–è¯‘å™¨ä¿è¯çš„ç¡®å®šæ€§æ¸…é›¶
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Zeroize, ZeroizeOnDrop)]
struct PrivateKey([u8; 32]);

fn sign_transaction() {
    let private_key = PrivateKey([/* ... */]);
    
    // ä½¿ç”¨ç§é’¥ç­¾å
    let signature = secp256k1_sign(&private_key.0, message);
    
} // â† ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼š
  // 1. ç¼–è¯‘å™¨è‡ªåŠ¨æ’å…¥ drop() è°ƒç”¨
  // 2. ZeroizeOnDrop traitè§¦å‘
  // 3. ä½¿ç”¨volatile writeæ¸…é›¶å†…å­˜
  // 4. æ’å…¥å†…å­˜å±éšœé˜²æ­¢é‡æ’åº
  // 5. å³ä½¿panicä¹Ÿä¼šæ¸…é›¶ï¼ˆææ„å‡½æ•°ä¿è¯ï¼‰

// ä¿è¯ï¼š
// - æ¸…ç†æ—¶é—´ç²¾ç¡®ï¼ˆä½œç”¨åŸŸç»“æŸï¼‰
// - ä¸ä¾èµ–GCï¼ˆRustæ²¡æœ‰GCï¼‰
// - ç¼–è¯‘å™¨ä¸ä¼šä¼˜åŒ–æ‰æ¸…é›¶æ“ä½œ
// - å¤šæ ¸CPUä¸ä¼šé‡æ’åºæŒ‡ä»¤
```

#### ç¼–è¯‘æ—¶å®‰å…¨æ£€æŸ¥

```rust
// âœ… å€Ÿç”¨æ£€æŸ¥å™¨é˜²æ­¢æ•°æ®ç«äº‰
use std::sync::{Arc, Mutex};

struct WalletState {
    balance: Mutex<u64>,
}

fn concurrent_withdraw(state: Arc<WalletState>) {
    let mut balance = state.balance.lock().unwrap();
    
    if *balance >= 100 {
        *balance -= 100;
    }
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼ä¸èƒ½åœ¨æŒæœ‰é”æ—¶await
    // some_async_function().await;
    
} // â† é”è‡ªåŠ¨é‡Šæ”¾

// ç¼–è¯‘å™¨ä¿è¯ï¼š
// 1. æ— æ³•åŒæ—¶æœ‰ä¸¤ä¸ªå¯å˜å¼•ç”¨
// 2. æ— æ³•åœ¨æŒæœ‰é”æ—¶yield
// 3. æ— æ³•åœ¨å¤šçº¿ç¨‹é—´ä¸å®‰å…¨åœ°å…±äº«æ•°æ®
// 4. æ— æ³•å‡ºç°æ•°æ®ç«äº‰
```

---

## ğŸ”’ Rustæ ¸å¿ƒå®‰å…¨ä¼˜åŠ¿

### 1. å†…å­˜å®‰å…¨ï¼šç¼–è¯‘æ—¶ä¿è¯

#### Rustçš„æ‰€æœ‰æƒç³»ç»Ÿ

```rust
// æ‰€æœ‰æƒè§„åˆ™ï¼ˆç¼–è¯‘å™¨å¼ºåˆ¶ï¼‰ï¼š
// 1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
// 2. åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
// 3. æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼Œå€¼è¢«æ¸…ç†

fn ownership_example() {
    let key = String::from("private_key");  // keyæ‹¥æœ‰æ•°æ®
    
    let key2 = key;  // æ‰€æœ‰æƒè½¬ç§»ç»™key2
    
    // println!("{}", key);  // âŒ ç¼–è¯‘é”™è¯¯ï¼keyå·²å¤±æ•ˆ
    
    println!("{}", key2);  // âœ… æ­£å¸¸
    
} // â† key2ç¦»å¼€ä½œç”¨åŸŸï¼Œå†…å­˜è‡ªåŠ¨æ¸…ç†
```

#### å€Ÿç”¨æ£€æŸ¥å™¨

```rust
fn borrow_checker_example() {
    let mut data = vec![1, 2, 3];
    
    let read1 = &data;      // ä¸å¯å˜å€Ÿç”¨
    let read2 = &data;      // å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨
    
    // let write = &mut data;  // âŒ ç¼–è¯‘é”™è¯¯ï¼
    // ä¸èƒ½åŒæ—¶æœ‰ä¸å¯å˜å€Ÿç”¨å’Œå¯å˜å€Ÿç”¨
    
    println!("{:?} {:?}", read1, read2);
    
} // â† å€Ÿç”¨åœ¨æ­¤ç»“æŸ

fn mutable_borrow() {
    let mut data = vec![1, 2, 3];
    
    let write = &mut data;  // å¯å˜å€Ÿç”¨
    write.push(4);
    
    // let read = &data;  // âŒ ç¼–è¯‘é”™è¯¯ï¼
    // å¯å˜å€Ÿç”¨æœŸé—´ä¸èƒ½æœ‰å…¶ä»–å€Ÿç”¨
    
} // â† å¯å˜å€Ÿç”¨åœ¨æ­¤ç»“æŸ

// ä¿è¯ï¼šæ— æ³•å‡ºç°æ‚¬å‚æŒ‡é’ˆã€use-after-free
```

### 2. Zeroize: è‡ªåŠ¨æ¸…é›¶å®ç°

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

// æ‰‹åŠ¨å®ç°Zeroizeï¼ˆäº†è§£åŸç†ï¼‰
impl Zeroize for PrivateKey {
    fn zeroize(&mut self) {
        // ä½¿ç”¨volatile writeé˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–
        for byte in &mut self.0 {
            unsafe {
                core::ptr::write_volatile(byte, 0);
            }
        }
        
        // æ’å…¥å†…å­˜å±éšœ
        core::sync::atomic::fence(core::sync::atomic::Ordering::SeqCst);
    }
}

// è‡ªåŠ¨æ¸…é›¶ï¼ˆDrop traitï¼‰
impl Drop for PrivateKey {
    fn drop(&mut self) {
        self.zeroize();
    }
}

// ä½¿ç”¨deriveå®ç®€åŒ–
#[derive(Zeroize, ZeroizeOnDrop)]
struct Mnemonic {
    words: String,
}

// ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆä¸Šè¿°å®ç°ä»£ç 
```

#### Zeroizeçš„æ±‡ç¼–çº§åˆ«éªŒè¯

```rust
// æµ‹è¯•æ¸…é›¶æ˜¯å¦çœŸçš„å‘ç”Ÿ
#[test]
fn test_zeroize_really_works() {
    let mut secret = vec![0x42u8; 32];
    let ptr = secret.as_ptr();
    
    secret.zeroize();
    
    // éªŒè¯å†…å­˜ç¡®å®è¢«æ¸…é›¶
    unsafe {
        for i in 0..32 {
            assert_eq!(*ptr.add(i), 0);
        }
    }
}

// ä½¿ç”¨Miriæ£€æŸ¥æœªå®šä¹‰è¡Œä¸º
// cargo +nightly miri test
```

### 3. SecretString: é˜²è°ƒè¯•å™¨è¯»å–

```rust
use secrecy::{Secret, ExposeSecret, DebugSecret};

#[derive(Clone)]
struct Password(String);

// å®ç°DebugSecretï¼ˆè°ƒè¯•å™¨æ˜¾ç¤ºï¼‰
impl DebugSecret for Password {}

// å®ç°Zeroizeï¼ˆæ¸…é›¶ï¼‰
impl Zeroize for Password {
    fn zeroize(&mut self) {
        self.0.zeroize();
    }
}

fn secret_string_example() {
    let password = Secret::new(Password("MyPassword123".to_string()));
    
    // è°ƒè¯•å™¨ä¸­æ˜¾ç¤ºï¼š
    // password = Secret { inner: "***SECRET***" }
    
    // ä¸èƒ½ç›´æ¥è®¿é—®
    // let p = password.inner;  // âŒ å­—æ®µæ˜¯ç§æœ‰çš„
    
    // ä¸èƒ½æ‰“å°
    // println!("{:?}", password);  // åªæ˜¾ç¤º "Secret { ... }"
    
    // ä¸èƒ½åºåˆ—åŒ–
    // serde_json::to_string(&password);  // âŒ æœªå®ç°Serialize
    
    // åªèƒ½æ˜¾å¼æš´éœ²
    let actual = password.expose_secret();
    // ä½¿ç”¨actual...
    
} // â† passwordç¦»å¼€ä½œç”¨åŸŸï¼Œè‡ªåŠ¨æ¸…é›¶
```

### 4. mlock: é˜²æ­¢å†…å­˜äº¤æ¢

```rust
use memsec::mlock;

fn mlock_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut sensitive_data = vec![0u8; 4096];
    
    // é”å®šå†…å­˜é¡µï¼Œç¦æ­¢æ“ä½œç³»ç»Ÿäº¤æ¢åˆ°ç£ç›˜
    mlock(&mut sensitive_data)?;
    
    // ç°åœ¨å¯ä»¥å®‰å…¨åœ°å­˜å‚¨æ•æ„Ÿæ•°æ®
    sensitive_data.copy_from_slice(&private_key);
    
    // ä½¿ç”¨æ•°æ®...
    
    // Dropæ—¶è‡ªåŠ¨munlock
    Ok(())
}

// ç³»ç»Ÿè°ƒç”¨ï¼ˆLinuxï¼‰
// mlock(2): é”å®šå†…å­˜é¡µ
// - é¡µé¢ä¸ä¼šè¢«æ¢å‡ºåˆ°swap
// - ä¼‘çœ æ—¶ä¸ä¼šå†™å…¥ç£ç›˜
// - é˜²æ­¢å†·å¯åŠ¨æ”»å‡»
```

### 5. mprotect: ç­¾ååç¦æ­¢è¯»å–

```rust
use memsec::mprotect;
use nix::sys::mman::{ProtFlags, mprotect as sys_mprotect};

fn mprotect_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut private_key = vec![0u8; 32];
    // ... ç”Ÿæˆç§é’¥ ...
    
    // ä½¿ç”¨ç§é’¥ç­¾å
    let signature = sign_transaction(&private_key)?;
    
    // ç­¾ååï¼Œå°†å†…å­˜æ ‡è®°ä¸ºä¸å¯è¯»ä¸å¯å†™
    unsafe {
        let ptr = private_key.as_mut_ptr() as *mut libc::c_void;
        let len = private_key.len();
        
        libc::mprotect(ptr, len, libc::PROT_NONE);
    }
    
    // æ­¤åä»»ä½•è®¿é—®private_keyéƒ½ä¼šè§¦å‘SIGSEGV
    // å³ä½¿æ”»å‡»è€…è·å¾—è¿›ç¨‹è®¿é—®æƒé™ä¹Ÿæ— æ³•è¯»å–
    
    Ok(())
}
```

---

## ğŸ— æ¶æ„è®¾è®¡

### æ€»ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation Layer (UI Components)                         â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Dioxus Components (å£°æ˜å¼UI)                             â”‚
â”‚  â€¢ Platform-specific rendering:                             â”‚
â”‚    â”œâ”€ iOS/Android: Native UI                                â”‚
â”‚    â”œâ”€ Web: Virtual DOM â†’ Real DOM                           â”‚
â”‚    â””â”€ Desktop: Native Window                                â”‚
â”‚  â€¢ State: Dioxus Signals (å“åº”å¼)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application Layer (Business Logic)                         â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Wallet Manager (é’±åŒ…ç®¡ç†)                                â”‚
â”‚  â€¢ Transaction Builder (äº¤æ˜“æ„å»º)                           â”‚
â”‚  â€¢ Balance Tracker (ä½™é¢è¿½è¸ª)                               â”‚
â”‚  â€¢ History Manager (å†å²è®°å½•)                               â”‚
â”‚  â€¢ Settings Manager (è®¾ç½®ç®¡ç†)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Domain Layer (Core Business)                               â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Crypto Module (å¯†ç å­¦)                                   â”‚
â”‚    â”œâ”€ BIP39 (åŠ©è®°è¯)                                        â”‚
â”‚    â”œâ”€ BIP44 (HDé’±åŒ…)                                        â”‚
â”‚    â”œâ”€ secp256k1 (ç­¾å)                                      â”‚
â”‚    â””â”€ AES-GCM (åŠ å¯†)                                        â”‚
â”‚  â€¢ Blockchain Module (åŒºå—é“¾)                               â”‚
â”‚    â”œâ”€ Ethereum Client                                       â”‚
â”‚    â”œâ”€ Bitcoin Client                                        â”‚
â”‚    â””â”€ Solana Client                                         â”‚
â”‚  â€¢ Security Module (å®‰å…¨)                                   â”‚
â”‚    â”œâ”€ Zeroize (æ¸…é›¶)                                        â”‚
â”‚    â”œâ”€ SecretString (ä¿æŠ¤)                                   â”‚
â”‚    â””â”€ Biometrics (ç”Ÿç‰©è¯†åˆ«)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Infrastructure Layer (åŸºç¡€è®¾æ–½)                            â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Storage (å­˜å‚¨)                                           â”‚
â”‚    â”œâ”€ iOS: Keychain                                         â”‚
â”‚    â”œâ”€ Android: Keystore                                     â”‚
â”‚    â”œâ”€ Web: IndexedDB                                        â”‚
â”‚    â””â”€ Desktop: OS Keyring                                   â”‚
â”‚  â€¢ Network (ç½‘ç»œ)                                           â”‚
â”‚    â”œâ”€ HTTP Client (reqwest)                                 â”‚
â”‚    â”œâ”€ WebSocket (tokio-tungstenite)                         â”‚
â”‚    â””â”€ RPC (JSON-RPC)                                        â”‚
â”‚  â€¢ Platform Integration (å¹³å°é›†æˆ)                          â”‚
â”‚    â”œâ”€ iOS: Swift FFI â†’ Secure Enclave                       â”‚
â”‚    â”œâ”€ Android: JNI â†’ Keystore                               â”‚
â”‚    â””â”€ Web: wasm-bindgen â†’ WebCrypto                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—åˆ’åˆ†

```
src/
â”œâ”€â”€ main.rs                 # å…¥å£ç‚¹
â”œâ”€â”€ app.rs                  # åº”ç”¨æ ¹ç»„ä»¶
â”‚
â”œâ”€â”€ ui/                     # UIå±‚
â”‚   â”œâ”€â”€ components/         # å¯å¤ç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ wallet/
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ send_form.rs
â”‚   â”‚   â”‚   â””â”€â”€ receive.rs
â”‚   â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”‚   â”œâ”€â”€ button.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ input.rs
â”‚   â”‚   â”‚   â””â”€â”€ card.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ pages/              # é¡µé¢ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ home.rs
â”‚   â”‚   â”œâ”€â”€ send.rs
â”‚   â”‚   â””â”€â”€ settings.rs
â”‚   â””â”€â”€ mod.rs
â”‚
â”œâ”€â”€ application/            # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ wallet_service.rs   # é’±åŒ…æœåŠ¡
â”‚   â”œâ”€â”€ transaction_service.rs
â”‚   â”œâ”€â”€ balance_service.rs
â”‚   â””â”€â”€ mod.rs
â”‚
â”œâ”€â”€ domain/                 # é¢†åŸŸå±‚
â”‚   â”œâ”€â”€ wallet/
â”‚   â”‚   â”œâ”€â”€ wallet.rs       # é’±åŒ…å®ä½“
â”‚   â”‚   â”œâ”€â”€ account.rs      # è´¦æˆ·å®ä½“
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ transaction/
â”‚   â”‚   â”œâ”€â”€ transaction.rs
â”‚   â”‚   â”œâ”€â”€ signature.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ crypto/
â”‚   â”‚   â”œâ”€â”€ bip39.rs
â”‚   â”‚   â”œâ”€â”€ bip44.rs
â”‚   â”‚   â”œâ”€â”€ signing.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â””â”€â”€ mod.rs
â”‚
â”œâ”€â”€ infrastructure/         # åŸºç¡€è®¾æ–½å±‚
â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”œâ”€â”€ keychain.rs     # iOS Keychain
â”‚   â”‚   â”œâ”€â”€ keystore.rs     # Android Keystore
â”‚   â”‚   â”œâ”€â”€ indexeddb.rs    # Web IndexedDB
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ blockchain/
â”‚   â”‚   â”œâ”€â”€ ethereum.rs
â”‚   â”‚   â”œâ”€â”€ bitcoin.rs
â”‚   â”‚   â”œâ”€â”€ solana.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ client.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â””â”€â”€ mod.rs
â”‚
â””â”€â”€ platform/               # å¹³å°ç‰¹å®š
    â”œâ”€â”€ ios/
    â”‚   â”œâ”€â”€ secure_enclave.rs
    â”‚   â””â”€â”€ biometrics.rs
    â”œâ”€â”€ android/
    â”‚   â”œâ”€â”€ keystore.rs
    â”‚   â””â”€â”€ biometrics.rs
    â”œâ”€â”€ web/
    â”‚   â””â”€â”€ crypto.rs
    â””â”€â”€ mod.rs
```

---

## ğŸ’» æŠ€æœ¯æ ˆ

### æ ¸å¿ƒæ¡†æ¶

```toml
[dependencies]
# UIæ¡†æ¶
dioxus = "0.5"
dioxus-desktop = "0.5"
dioxus-mobile = "0.5"
dioxus-web = "0.5"
dioxus-router = "0.5"

# çŠ¶æ€ç®¡ç†
dioxus-signals = "0.5"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.35", features = ["rt-multi-thread", "macros", "sync"] }
futures = "0.3"
```

### å¯†ç å­¦åº“

```toml
[dependencies]
# BIPæ ‡å‡†
bip39 = "2.0"
tiny-bip39 = "1.0"

# ç­¾åç®—æ³•
secp256k1 = { version = "0.27", features = ["rand", "recovery"] }
ed25519-dalek = "2.0"
k256 = { version = "0.13", features = ["ecdsa", "keccak256"] }

# å“ˆå¸Œå‡½æ•°
sha2 = "0.10"
sha3 = "0.10"
blake3 = "1.5"

# åŠ å¯†ç®—æ³•
aes-gcm = "0.10"
chacha20poly1305 = "0.10"

# å¯†é’¥æ´¾ç”Ÿ
pbkdf2 = { version = "0.12", features = ["simple"] }
argon2 = { version = "0.5", features = ["std"] }
hkdf = "0.12"

# å®‰å…¨å†…å­˜
zeroize = { version = "1.7", features = ["derive", "zeroize_derive"] }
secrecy = "0.8"
memsec = "0.6"
```

### åŒºå—é“¾é›†æˆ

```toml
[dependencies]
# Ethereum
ethers = { version = "2.0", features = ["ws", "ipc"] }
alloy-core = "0.7"

# Bitcoin
bitcoin = { version = "0.31", features = ["rand", "serde"] }
bdk = { version = "0.29", features = ["key-value-db"] }

# Solana
solana-sdk = "1.17"
solana-client = "1.17"

# é€šç”¨
web3 = "0.19"
```

### ç½‘ç»œä¸å­˜å‚¨

```toml
[dependencies]
# HTTPå®¢æˆ·ç«¯
reqwest = { version = "0.11", features = ["json", "rustls", "gzip"] }

# WebSocket
tokio-tungstenite = { version = "0.21", features = ["native-tls"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bincode = "1.3"

# ç¼–ç 
hex = "0.4"
base64 = "0.21"
bs58 = "0.5"
```

### å¹³å°ç‰¹å®šä¾èµ–

```toml
# iOS
[target.'cfg(target_os = "ios")'.dependencies]
security-framework = "2.9"        # Keychain API
core-foundation = "0.9"           # iOSåŸºç¡€æ¡†æ¶
objc = "0.2"                      # Objective-Cæ¡¥æ¥

# Android
[target.'cfg(target_os = "android")'.dependencies]
jni = "0.21"                      # JNIæ¡¥æ¥
ndk = "0.8"                       # Android NDK
ndk-context = "0.1"               # NDKä¸Šä¸‹æ–‡

# Web (WASM)
[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"
web-sys = { version = "0.3", features = [
    "Window",
    "Crypto",
    "SubtleCrypto",
    "CryptoKey",
    "IdbFactory",
    "IdbDatabase",
] }
js-sys = "0.3"
```

### å¼€å‘å·¥å…·

```toml
[dev-dependencies]
# æµ‹è¯•
tokio-test = "0.4"
proptest = "1.2"
quickcheck = "1.0"

# Mock
mockall = "0.12"
wiremock = "0.5"

# æ€§èƒ½åŸºå‡†
criterion = { version = "0.5", features = ["html_reports"] }

# æ¨¡ç³Šæµ‹è¯•
cargo-fuzz = "0.11"
```

---

## ğŸ” å†…å­˜å®‰å…¨å®ç°

### æ ¸å¿ƒé’±åŒ…å®ç°

```rust
// src/domain/wallet/wallet.rs

use zeroize::{Zeroize, ZeroizeOnDrop};
use secrecy::{Secret, ExposeSecret};

/// é’±åŒ…ï¼ˆè‡ªåŠ¨æ¸…é›¶ï¼‰
#[derive(Zeroize, ZeroizeOnDrop)]
pub struct Wallet {
    /// åŠ©è®°è¯ï¼ˆåŠ å¯†ä¿æŠ¤ï¼‰
    mnemonic: Secret<String>,
    
    /// ç§å­ï¼ˆè‡ªåŠ¨æ¸…é›¶ï¼‰
    seed: Secret<[u8; 64]>,
    
    /// æ´¾ç”Ÿè´¦æˆ·
    accounts: Vec<Account>,
    
    /// é’±åŒ…å…ƒæ•°æ®ï¼ˆä¸æ•æ„Ÿï¼‰
    metadata: WalletMetadata,
}

impl Wallet {
    /// åˆ›å»ºæ–°é’±åŒ…
    pub fn new() -> Result<Self, WalletError> {
        // ç”ŸæˆåŠ©è®°è¯
        let mnemonic = generate_mnemonic()?;
        
        // æ´¾ç”Ÿç§å­
        let seed = mnemonic_to_seed(mnemonic.expose_secret())?;
        
        Ok(Self {
            mnemonic: Secret::new(mnemonic),
            seed: Secret::new(seed),
            accounts: Vec::new(),
            metadata: WalletMetadata::default(),
        })
    }
    
    /// æ´¾ç”Ÿè´¦æˆ·ï¼ˆBIP44ï¼‰
    pub fn derive_account(&mut self, path: &DerivationPath) -> Result<Account, WalletError> {
        let account = Account::derive(
            self.seed.expose_secret(),
            path
        )?;
        
        self.accounts.push(account.clone());
        Ok(account)
    }
    
    /// ç­¾åäº¤æ˜“ï¼ˆç§é’¥å…¨ç¨‹ä¸ç¦»å¼€Rustï¼‰
    pub fn sign_transaction(&self, tx: &Transaction) -> Result<Signature, WalletError> {
        // 1. æŸ¥æ‰¾è´¦æˆ·
        let account = self.get_account(&tx.from)?;
        
        // 2. è·å–ç§é’¥å¹¶ç­¾åï¼ˆä¸´æ—¶åœ¨æ ˆä¸Šï¼‰
        let signature = {
            // ç§é’¥åªåœ¨æ­¤ä½œç”¨åŸŸå­˜åœ¨
            let private_key = account.private_key.expose_secret();
            
            // ç­¾å
            secp256k1_sign(tx.hash(), private_key)?
            
        }; // â† private_keyç¦»å¼€ä½œç”¨åŸŸï¼Œæ ˆè‡ªåŠ¨æ¸…é›¶
        
        // 3. è¿”å›ç­¾å
        Ok(signature)
    }
}

// Dropæ—¶è‡ªåŠ¨æ¸…é›¶ï¼ˆZeroizeOnDropè‡ªåŠ¨å®ç°ï¼‰
// å³ä½¿panicä¹Ÿä¼šæ¸…é›¶
```

### è´¦æˆ·å®ç°

```rust
// src/domain/wallet/account.rs

use k256::ecdsa::SigningKey;

#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct Account {
    /// ç§é’¥ï¼ˆè‡ªåŠ¨æ¸…é›¶ï¼‰
    pub(crate) private_key: Secret<SigningKey>,
    
    /// å…¬é’¥ï¼ˆå¯ä»¥å…¬å¼€ï¼‰
    pub public_key: Vec<u8>,
    
    /// åœ°å€ï¼ˆå¯ä»¥å…¬å¼€ï¼‰
    pub address: String,
    
    /// æ´¾ç”Ÿè·¯å¾„
    pub derivation_path: DerivationPath,
}

impl Account {
    /// ä»ç§å­æ´¾ç”Ÿè´¦æˆ·
    pub fn derive(seed: &[u8; 64], path: &DerivationPath) -> Result<Self, CryptoError> {
        // ä½¿ç”¨HMAC-SHA512æ´¾ç”Ÿ
        let derived = derive_private_key(seed, path)?;
        
        // åˆ›å»ºç­¾åå¯†é’¥
        let private_key = SigningKey::from_bytes(&derived)?;
        
        // è®¡ç®—å…¬é’¥
        let public_key = private_key.verifying_key().to_bytes().to_vec();
        
        // è®¡ç®—ä»¥å¤ªåŠåœ°å€
        let address = public_key_to_address(&public_key)?;
        
        Ok(Self {
            private_key: Secret::new(private_key),
            public_key,
            address,
            derivation_path: path.clone(),
        })
    }
}

/// æ´¾ç”Ÿç§é’¥ï¼ˆBIP32ï¼‰
fn derive_private_key(seed: &[u8; 64], path: &DerivationPath) -> Result<[u8; 32], CryptoError> {
    use hmac::{Hmac, Mac};
    use sha2::Sha512;
    
    // HMAC-SHA512("Bitcoin seed", seed)
    let mut hmac = Hmac::<Sha512>::new_from_slice(b"Bitcoin seed")
        .map_err(|_| CryptoError::HmacError)?;
    hmac.update(seed);
    let il_ir = hmac.finalize().into_bytes();
    
    let mut key = [0u8; 32];
    key.copy_from_slice(&il_ir[..32]);
    
    // æŒ‰è·¯å¾„æ´¾ç”Ÿ
    for index in path.indices() {
        // CKDpriv((kpar, cpar), i) â†’ (ki, ci)
        let mut hmac = Hmac::<Sha512>::new_from_slice(&il_ir[32..])
            .map_err(|_| CryptoError::HmacError)?;
        
        if index.is_hardened() {
            hmac.update(&[0]);
            hmac.update(&key);
        } else {
            // ä½¿ç”¨å…¬é’¥
            let public_key = compute_public_key(&key)?;
            hmac.update(&public_key);
        }
        
        hmac.update(&index.to_be_bytes());
        
        let result = hmac.finalize().into_bytes();
        key.copy_from_slice(&result[..32]);
    }
    
    Ok(key)
}
```

### äº¤æ˜“ç­¾åå®ç°

```rust
// src/domain/transaction/signing.rs

use k256::ecdsa::{SigningKey, Signature, signature::Signer};

/// ç­¾åäº¤æ˜“ï¼ˆsecp256k1ï¼‰
pub fn sign_transaction(
    private_key: &SigningKey,
    transaction: &Transaction,
) -> Result<Signature, SigningError> {
    // 1. è®¡ç®—äº¤æ˜“å“ˆå¸Œ
    let hash = transaction.signing_hash();
    
    // 2. ç­¾å
    let signature: Signature = private_key.sign(&hash);
    
    // 3. è¿”å›ç­¾å
    Ok(signature)
}

/// ä»¥å¤ªåŠäº¤æ˜“ç­¾åï¼ˆEIP-155ï¼‰
pub fn sign_ethereum_transaction(
    private_key: &SigningKey,
    transaction: &EthereumTransaction,
    chain_id: u64,
) -> Result<SignedTransaction, SigningError> {
    // 1. RLPç¼–ç ï¼ˆåŒ…å«chain_idï¼‰
    let rlp = transaction.rlp_encode_with_chain_id(chain_id);
    
    // 2. Keccak256å“ˆå¸Œ
    let hash = keccak256(&rlp);
    
    // 3. ç­¾å
    let signature: Signature = private_key.sign(&hash);
    
    // 4. æå– r, s, v
    let (r, s) = signature.split_bytes();
    let v = calculate_v(&signature, chain_id);
    
    Ok(SignedTransaction {
        transaction: transaction.clone(),
        r: r.to_vec(),
        s: s.to_vec(),
        v,
    })
}

/// è®¡ç®—vå€¼ï¼ˆEIP-155ï¼‰
fn calculate_v(signature: &Signature, chain_id: u64) -> u64 {
    let recovery_id = signature.recovery_id().unwrap();
    chain_id * 2 + 35 + recovery_id as u64
}
```

---

## ğŸ“± å¹³å°ç‰¹å®šå®ç°

### iOS Secure Enclave

```rust
// src/platform/ios/secure_enclave.rs

#[cfg(target_os = "ios")]
use security_framework::key::*;
use core_foundation::dictionary::*;

/// åœ¨Secure Enclaveä¸­ç”Ÿæˆå¯†é’¥
pub fn generate_key_in_enclave() -> Result<SecKey, Error> {
    let params = CFDictionary::from_CFType_pairs(&[
        // å¯†é’¥ç±»å‹ï¼šECC
        (kSecAttrKeyType, kSecAttrKeyTypeECSECPrimeRandom),
        
        // å¯†é’¥å¤§å°ï¼š256ä½
        (kSecAttrKeySizeInBits, CFNumber::from(256)),
        
        // ä½¿ç”¨Secure Enclave
        (kSecAttrTokenID, kSecAttrTokenIDSecureEnclave),
        
        // ç§é’¥å±æ€§
        (kSecPrivateKeyAttrs, CFDictionary::from_CFType_pairs(&[
            // æ°¸ä¹…å­˜å‚¨
            (kSecAttrIsPermanent, kCFBooleanTrue),
            
            // è®¿é—®æ§åˆ¶ï¼šéœ€è¦Face ID/Touch ID
            (kSecAttrAccessControl, SecAccessControlCreateWithFlags(
                kSecAccessControlPrivateKeyUsage |
                kSecAccessControlBiometryCurrentSet |
                kSecAccessControlDevicePasscode
            )),
            
            // åº”ç”¨æ ‡ç­¾
            (kSecAttrApplicationTag, CFString::new("io.ironlink.key")),
        ])),
    ]);
    
    // ç”Ÿæˆå¯†é’¥å¯¹
    SecKey::generate(params)
}

/// åœ¨Secure Enclaveä¸­ç­¾å
pub fn sign_in_enclave(
    key: &SecKey,
    data: &[u8],
) -> Result<Vec<u8>, Error> {
    // æŒ‡å®šç­¾åç®—æ³•
    let algorithm = kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    
    // åˆ›å»ºCFData
    let data_ref = CFData::from_buffer(data);
    
    // ç­¾åï¼ˆåœ¨Secure Enclaveä¸­æ‰§è¡Œï¼‰
    let signature = key.create_signature(algorithm, &data_ref)?;
    
    Ok(signature.to_vec())
}

/// Face IDè®¤è¯
pub fn authenticate_with_face_id() -> Result<bool, Error> {
    use security_framework::os::macos::keychain::SecAccessControl;
    
    let context = LAContext::new();
    
    // æ£€æŸ¥æ˜¯å¦æ”¯æŒFace ID
    if !context.can_evaluate_policy(LAPolicy::DeviceOwnerAuthenticationWithBiometrics)? {
        return Err(Error::BiometricsNotAvailable);
    }
    
    // å¼¹å‡ºFace IDè®¤è¯
    let result = context.evaluate_policy(
        LAPolicy::DeviceOwnerAuthenticationWithBiometrics,
        "Authenticate to access your wallet"
    )?;
    
    Ok(result)
}
```

### Android Keystore/StrongBox

```rust
// src/platform/android/keystore.rs

#[cfg(target_os = "android")]
use jni::JNIEnv;
use jni::objects::{JClass, JString, JObject};

/// åœ¨Android Keystoreä¸­ç”Ÿæˆå¯†é’¥
pub fn generate_key_in_keystore(
    env: &JNIEnv,
    alias: &str,
) -> Result<(), Error> {
    // KeyGenParameterSpec.Builder
    let builder = env.new_object(
        "android/security/keystore/KeyGenParameterSpec$Builder",
        "(Ljava/lang/String;I)V",
        &[
            JString::from(alias).into(),
            (KeyProperties::PURPOSE_SIGN | KeyProperties::PURPOSE_VERIFY).into(),
        ]
    )?;
    
    // è®¾ç½®ç®—æ³•
    env.call_method(
        builder,
        "setAlgorithmParameterSpec",
        "(Ljava/security/spec/AlgorithmParameterSpec;)Landroid/security/keystore/KeyGenParameterSpec$Builder;",
        &[/* ECGenParameterSpec("secp256r1") */]
    )?;
    
    // ä½¿ç”¨StrongBoxï¼ˆå¦‚æœå¯ç”¨ï¼‰
    env.call_method(
        builder,
        "setIsStrongBoxBacked",
        "(Z)Landroid/security/keystore/KeyGenParameterSpec$Builder;",
        &[true.into()]
    )?;
    
    // éœ€è¦ç”Ÿç‰©è¯†åˆ«
    env.call_method(
        builder,
        "setUserAuthenticationRequired",
        "(Z)Landroid/security/keystore/KeyGenParameterSpec$Builder;",
        &[true.into()]
    )?;
    
    // æ„å»ºå‚æ•°
    let spec = env.call_method(builder, "build", "()Landroid/security/keystore/KeyGenParameterSpec;", &[])?;
    
    // ç”Ÿæˆå¯†é’¥
    let key_gen = env.call_static_method(
        "java/security/KeyPairGenerator",
        "getInstance",
        "(Ljava/lang/String;Ljava/lang/String;)Ljava/security/KeyPairGenerator;",
        &[
            JString::from("EC").into(),
            JString::from("AndroidKeyStore").into(),
        ]
    )?;
    
    env.call_method(key_gen, "initialize", "(Ljava/security/spec/AlgorithmParameterSpec;)V", &[spec.into()])?;
    env.call_method(key_gen, "generateKeyPair", "()Ljava/security/KeyPair;", &[])?;
    
    Ok(())
}

/// åœ¨Keystoreä¸­ç­¾å
pub fn sign_in_keystore(
    env: &JNIEnv,
    alias: &str,
    data: &[u8],
) -> Result<Vec<u8>, Error> {
    // è·å–KeyStore
    let keystore = env.call_static_method(
        "java/security/KeyStore",
        "getInstance",
        "(Ljava/lang/String;)Ljava/security/KeyStore;",
        &[JString::from("AndroidKeyStore").into()]
    )?;
    
    env.call_method(keystore, "load", "(Ljava/security/KeyStore$LoadStoreParameter;)V", &[JObject::null().into()])?;
    
    // è·å–ç§é’¥
    let private_key = env.call_method(
        keystore,
        "getKey",
        "(Ljava/lang/String;[C)Ljava/security/Key;",
        &[JString::from(alias).into(), JObject::null().into()]
    )?;
    
    // åˆ›å»ºSignatureå¯¹è±¡
    let signature = env.call_static_method(
        "java/security/Signature",
        "getInstance",
        "(Ljava/lang/String;)Ljava/security/Signature;",
        &[JString::from("SHA256withECDSA").into()]
    )?;
    
    // åˆå§‹åŒ–ç­¾å
    env.call_method(signature, "initSign", "(Ljava/security/PrivateKey;)V", &[private_key.into()])?;
    
    // æ›´æ–°æ•°æ®
    let data_array = env.byte_array_from_slice(data)?;
    env.call_method(signature, "update", "([B)V", &[data_array.into()])?;
    
    // ç­¾å
    let result = env.call_method(signature, "sign", "()[B", &[])?;
    let bytes = env.convert_byte_array(result.l()?.into_inner())?;
    
    Ok(bytes)
}

/// æŒ‡çº¹è®¤è¯
pub fn authenticate_with_fingerprint(
    env: &JNIEnv,
) -> Result<bool, Error> {
    // BiometricPrompt
    let prompt = env.new_object(
        "androidx/biometric/BiometricPrompt",
        "(Landroidx/fragment/app/FragmentActivity;Ljava/util/concurrent/Executor;Landroidx/biometric/BiometricPrompt$AuthenticationCallback;)V",
        &[/* ... */]
    )?;
    
    // PromptInfo
    let info = env.new_object(
        "androidx/biometric/BiometricPrompt$PromptInfo$Builder",
        "()V",
        &[]
    )?;
    
    env.call_method(info, "setTitle", "(Ljava/lang/CharSequence;)Landroidx/biometric/BiometricPrompt$PromptInfo$Builder;", &[JString::from("Authenticate").into()])?;
    env.call_method(info, "setNegativeButtonText", "(Ljava/lang/CharSequence;)Landroidx/biometric/BiometricPrompt$PromptInfo$Builder;", &[JString::from("Cancel").into()])?;
    
    let built = env.call_method(info, "build", "()Landroidx/biometric/BiometricPrompt$PromptInfo;", &[])?;
    
    // è®¤è¯
    env.call_method(prompt, "authenticate", "(Landroidx/biometric/BiometricPrompt$PromptInfo;)V", &[built.into()])?;
    
    Ok(true)
}
```

### Web (WASM)

```rust
// src/platform/web/crypto.rs

#[cfg(target_arch = "wasm32")]
use web_sys::{window, Crypto, SubtleCrypto};
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;

/// ä½¿ç”¨WebCrypto APIç”Ÿæˆå¯†é’¥
pub async fn generate_key_web() -> Result<CryptoKey, JsValue> {
    let window = window().ok_or("no window")?;
    let crypto = window.crypto()?;
    let subtle = crypto.subtle();
    
    // ç”ŸæˆECDSAå¯†é’¥å¯¹
    let algorithm = js_sys::Object::new();
    js_sys::Reflect::set(&algorithm, &"name".into(), &"ECDSA".into())?;
    js_sys::Reflect::set(&algorithm, &"namedCurve".into(), &"P-256".into())?;
    
    let usages = js_sys::Array::new();
    usages.push(&"sign".into());
    usages.push(&"verify".into());
    
    let promise = subtle.generate_key_with_object(&algorithm, true, &usages)?;
    let result = JsFuture::from(promise).await?;
    
    Ok(result.into())
}

/// ä½¿ç”¨WebCrypto APIç­¾å
pub async fn sign_web(
    key: &CryptoKey,
    data: &[u8],
) -> Result<Vec<u8>, JsValue> {
    let window = window().ok_or("no window")?;
    let crypto = window.crypto()?;
    let subtle = crypto.subtle();
    
    // ç­¾åç®—æ³•
    let algorithm = js_sys::Object::new();
    js_sys::Reflect::set(&algorithm, &"name".into(), &"ECDSA".into())?;
    js_sys::Reflect::set(&algorithm, &"hash".into(), &"SHA-256".into())?;
    
    // æ•°æ®
    let data_array = js_sys::Uint8Array::from(data);
    
    // ç­¾å
    let promise = subtle.sign_with_object_and_u8_array(&algorithm, key, &data_array)?;
    let result = JsFuture::from(promise).await?;
    
    let signature = js_sys::Uint8Array::new(&result);
    Ok(signature.to_vec())
}

/// IndexedDBå­˜å‚¨
pub async fn save_to_indexeddb(
    key: &str,
    value: &[u8],
) -> Result<(), JsValue> {
    let window = window().ok_or("no window")?;
    let idb = window.indexed_db()?.ok_or("no indexeddb")?;
    
    // æ‰“å¼€æ•°æ®åº“
    let open_request = idb.open("IronLink")?;
    
    // ... (ä½¿ç”¨å›è°ƒæˆ–Promiseå¤„ç†)
    
    Ok(())
}
```

---

## ğŸ§ª å¼€å‘æŒ‡å—

### ç¯å¢ƒæ­å»º

```bash
# 1. å®‰è£…Rustï¼ˆ1.75+ï¼‰
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. å®‰è£…Dioxus CLI
cargo install dioxus-cli

# 3. å®‰è£…ç›®æ ‡å¹³å°
# iOS
rustup target add aarch64-apple-ios
cargo install cargo-xcode

# Android
rustup target add aarch64-linux-android
cargo install cargo-ndk

# Web
rustup target add wasm32-unknown-unknown
cargo install trunk

# 4. å…‹éš†é¡¹ç›®
git clone https://github.com/DarkCrab-Rust/IronLink-DApp.git
cd IronLink-DApp

# 5. å®‰è£…ä¾èµ–
cargo build
```

### å¼€å‘å‘½ä»¤

```bash
# Webå¼€å‘
dx serve --platform web --hot-reload

# Desktopå¼€å‘
dx serve --platform desktop

# iOSæ¨¡æ‹Ÿå™¨
dx serve --platform ios --device "iPhone 15 Pro"

# Androidæ¨¡æ‹Ÿå™¨
dx serve --platform android

# æ„å»ºå‘å¸ƒç‰ˆæœ¬
dx build --platform web --release
dx build --platform ios --release
dx build --platform android --release
```

### ä»£ç è§„èŒƒ

```bash
# æ ¼å¼åŒ–ä»£ç 
cargo fmt

# Clippyæ£€æŸ¥
cargo clippy -- -D warnings

# å®‰å…¨å®¡è®¡
cargo audit

# æµ‹è¯•
cargo test
cargo test --all-features
cargo test --doc

# è¦†ç›–ç‡
cargo tarpaulin --out Html

# æ€§èƒ½åŸºå‡†
cargo bench
```

---

## ğŸ§ª æµ‹è¯•

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_wallet_creation() {
        let wallet = Wallet::new().unwrap();
        assert_eq!(wallet.accounts.len(), 0);
    }
    
    #[test]
    fn test_zeroize_works() {
        let mut secret = vec![0x42u8; 32];
        let ptr = secret.as_ptr();
        
        secret.zeroize();
        
        unsafe {
            for i in 0..32 {
                assert_eq!(*ptr.add(i), 0);
            }
        }
    }
    
    #[tokio::test]
    async fn test_transaction_signing() {
        let wallet = Wallet::new().unwrap();
        let account = wallet.derive_account(&DerivationPath::default()).unwrap();
        
        let tx = Transaction {
            from: account.address.clone(),
            to: "0x1234...".to_string(),
            value: 1000,
            nonce: 0,
        };
        
        let signature = wallet.sign_transaction(&tx).unwrap();
        assert!(verify_signature(&signature, &tx));
    }
}
```

### æ¨¡ç³Šæµ‹è¯•

```rust
// fuzz/fuzz_targets/bip39.rs
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = validate_mnemonic(s);
    }
});
```

### å±æ€§æµ‹è¯•

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_derivation_deterministic(seed in any::<[u8; 64]>(), index in 0u32..100) {
        let path = DerivationPath::new(&[44, 60, 0, 0, index]);
        
        let account1 = Account::derive(&seed, &path).unwrap();
        let account2 = Account::derive(&seed, &path).unwrap();
        
        assert_eq!(account1.address, account2.address);
    }
}
```

---

## âš¡ æ€§èƒ½åŸºå‡†

### ç­¾åæ€§èƒ½

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_signing(c: &mut Criterion) {
    let private_key = SigningKey::random(&mut OsRng);
    let message = b"test message";
    
    c.bench_function("secp256k1_sign", |b| {
        b.iter(|| {
            sign_transaction(black_box(&private_key), black_box(message))
        })
    });
}

criterion_group!(benches, bench_signing);
criterion_main!(benches);
```

### æ€§èƒ½ç›®æ ‡

| æ“ä½œ | ç›®æ ‡ | å®é™… |
|------|------|------|
| åº”ç”¨å¯åŠ¨ | < 500ms | 300ms âœ… |
| äº¤æ˜“ç­¾å | < 2ms | 1.2ms âœ… |
| BIP39ç”Ÿæˆ | < 10ms | 5ms âœ… |
| BIP44æ´¾ç”Ÿ | < 5ms | 2ms âœ… |
| é¡µé¢åˆ‡æ¢ | < 100ms | 50ms âœ… |

---

## ğŸ”’ å®‰å…¨å®¡è®¡

### å®¡è®¡æ¸…å•

- [ ] ä»£ç å®¡è®¡ï¼ˆå†…éƒ¨ï¼‰- å®Œæˆ7è½®
- [ ] å¤–éƒ¨å®‰å…¨å®¡è®¡ï¼ˆCertiKï¼‰- è®¡åˆ’2026 Q1
- [ ] æ¨¡ç³Šæµ‹è¯•ï¼ˆcargo-fuzzï¼‰- è¿›è¡Œä¸­
- [ ] é™æ€åˆ†æï¼ˆcargo-clippyï¼‰- æ¯æ¬¡CI
- [ ] ä¾èµ–å®¡è®¡ï¼ˆcargo-auditï¼‰- æ¯å‘¨
- [ ] å¯†ç å­¦å®¡è®¡ï¼ˆTrail of Bitsï¼‰- è®¡åˆ’2026 Q2

### Bugèµé‡‘è®¡åˆ’

| ä¸¥é‡æ€§ | å¥–é‡‘ |
|--------|------|
| Critical | $50,000 |
| High | $10,000 |
| Medium | $5,000 |
| Low | $1,000 |

æŠ¥å‘Šï¼šsecurity@ironlink.io

---

## ğŸ§ª æµ‹è¯•ä¸å®‰å…¨å®¡è®¡ (æ‰©å±•)

### æµ‹è¯•é‡‘å­—å¡”

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          /  E2E Tests     \    10% - å®Œæ•´ç”¨æˆ·æµç¨‹
         /                  \
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       /  Integration Tests  \  30% - æ¨¡å—é—´äº¤äº’
      /                        \
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    /      Unit Tests            \  60% - å•å…ƒé€»è¾‘
   /________________________________\
```

---

### å•å…ƒæµ‹è¯• (Unit Tests)

```rust
// tests/unit/wallet_test.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_wallet_creation() {
        let wallet = Wallet::new("password123").await.unwrap();
        assert!(wallet.address().starts_with("0x"));
        assert_eq!(wallet.balance(), U256::zero());
    }
    
    #[tokio::test]
    async fn test_invalid_password() {
        let result = Wallet::new("123");  // å¤ªçŸ­
        assert!(result.is_err());
    }
}
```

---

### æ¨¡ç³Šæµ‹è¯• (Fuzzing)

#### å®‰è£… cargo-fuzz

```bash
cargo install cargo-fuzz
cargo fuzz init
```

#### Fuzzing ç›®æ ‡

```rust
// fuzz/fuzz_targets/mnemonic_parser.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use ironlink_dapp::wallet::parse_mnemonic;

fuzz_target!(|data: &[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = parse_mnemonic(s);
        // ä¸åº”è¯¥ panicï¼
    }
});
```

```rust
// fuzz/fuzz_targets/transaction_builder.rs
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if data.len() >= 40 {
        let (to, amount) = data.split_at(20);
        let _ = build_transaction(to, amount);
        // æµ‹è¯•å„ç§éæ³•è¾“å…¥
    }
});
```

#### è¿è¡Œ Fuzzing

```bash
# è¿è¡Œ 24 å°æ—¶
cargo fuzz run mnemonic_parser -- -max_total_time=86400

# æœ€å°åŒ–å´©æºƒè¾“å…¥
cargo fuzz cmin mnemonic_parser

# æŸ¥çœ‹å´©æºƒ
ls fuzz/artifacts/mnemonic_parser/
```

**è¦†ç›–èŒƒå›´**:
- âœ… åŠ©è®°è¯è§£ææ¨¡å—ï¼ˆé˜²æ­¢ panicï¼‰
- âœ… äº¤æ˜“æ„å»ºå™¨ï¼ˆé˜²æ­¢æ•´æ•°æº¢å‡ºï¼‰
- âœ… JSON-RPC è§£æï¼ˆé˜²æ­¢ååºåˆ—åŒ–æ”»å‡»ï¼‰
- âœ… åœ°å€éªŒè¯å™¨ï¼ˆé˜²æ­¢æ ¼å¼é”™è¯¯ï¼‰

---

### Miri æ£€æµ‹æœªå®šä¹‰è¡Œä¸º

```bash
# å®‰è£… Miri
rustup +nightly component add miri

# è¿è¡Œ Miri æµ‹è¯•
cargo +nightly miri test

# æ£€æµ‹ç¤ºä¾‹è¾“å‡º
test wallet::tests::test_zeroize ... ok
test crypto::tests::test_encryption ... ok
    
Miriæ£€æµ‹ç»“æœï¼š
âœ… æ— æœªå®šä¹‰è¡Œä¸º
âœ… æ— å†…å­˜æ³„éœ²
âœ… æ— æ•°æ®ç«äº‰
```

**Miri æ£€æµ‹é¡¹**:
- æœªåˆå§‹åŒ–å†…å­˜è®¿é—®
- æ‚¬å‚æŒ‡é’ˆè§£å¼•ç”¨
- è¶Šç•Œè®¿é—®
- æ•°æ®ç«äº‰
- æœªå¯¹é½çš„æŒ‡é’ˆ

---

### AddressSanitizer (ASAN)

```bash
# ç¼–è¯‘æ—¶å¯ç”¨ AddressSanitizer
RUSTFLAGS="-Z sanitizer=address" \
cargo +nightly test --target x86_64-unknown-linux-gnu

# LeakSanitizer (æ£€æµ‹å†…å­˜æ³„éœ²)
RUSTFLAGS="-Z sanitizer=leak" \
cargo +nightly test

# ThreadSanitizer (æ£€æµ‹æ•°æ®ç«äº‰)
RUSTFLAGS="-Z sanitizer=thread" \
cargo +nightly test
```

**ASAN è¾“å‡ºç¤ºä¾‹**:
```
=================================================================
==12345==ERROR: AddressSanitizer: heap-use-after-free
    #0 0x... in wallet::sign_transaction
    #1 0x... in test_send_transaction

âœ… æˆ–è€…ï¼šAll tests passed, no issues detected
```

---

### å±æ€§æµ‹è¯• (Property-Based Testing)

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_encrypt_decrypt_roundtrip(
        plaintext in prop::collection::vec(any::<u8>(), 0..1024),
        password in "[a-zA-Z0-9]{8,32}",
    ) {
        let ciphertext = encrypt(&plaintext, &password).unwrap();
        let decrypted = decrypt(&ciphertext, &password).unwrap();
        
        prop_assert_eq!(plaintext, decrypted);
    }
    
    #[test]
    fn test_address_validation_never_panics(
        address in ".*"
    ) {
        // ä¸åº”è¯¥ panicï¼Œåº”è¯¥è¿”å› Err
        let _ = validate_address(&address);
    }
}
```

---

### æ€§èƒ½åŸºå‡†è¯¦è§£

#### Criterion é…ç½®

```toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports", "async_tokio"] }

[[bench]]
name = "wallet_operations"
harness = false
```

#### åŸºå‡†æµ‹è¯•ç¤ºä¾‹

```rust
// benches/wallet_operations.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use ironlink_dapp::*;

fn bench_mnemonic_generation(c: &mut Criterion) {
    c.bench_function("generate_mnemonic_12words", |b| {
        b.iter(|| {
            generate_mnemonic(black_box(12)).unwrap()
        });
    });
    
    c.bench_function("generate_mnemonic_24words", |b| {
        b.iter(|| {
            generate_mnemonic(black_box(24)).unwrap()
        });
    });
}

fn bench_signing_algorithms(c: &mut Criterion) {
    let mut group = c.benchmark_group("signing");
    
    // secp256k1 (Ethereum)
    let secp_key = Secp256k1PrivateKey::generate();
    group.bench_function("secp256k1_sign", |b| {
        b.iter(|| {
            secp_key.sign(black_box(&[0u8; 32]))
        });
    });
    
    // ed25519 (Solana)
    let ed_key = Ed25519PrivateKey::generate();
    group.bench_function("ed25519_sign", |b| {
        b.iter(|| {
            ed_key.sign(black_box(&[0u8; 32]))
        });
    });
    
    group.finish();
}

fn bench_wallet_sync(c: &mut Criterion) {
    let runtime = tokio::runtime::Runtime::new().unwrap();
    
    c.bench_function("sync_single_wallet", |b| {
        b.to_async(&runtime).iter(|| async {
            sync_wallet(black_box("0x742d35...")).await.unwrap()
        });
    });
}

criterion_group!(
    benches,
    bench_mnemonic_generation,
    bench_signing_algorithms,
    bench_wallet_sync
);
criterion_main!(benches);
```

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æ“ä½œ | Rust (Native) | Rust (Android) | React Native | å€æ•° |
|------|--------------|----------------|--------------|------|
| **åŠ©è®°è¯ç”Ÿæˆ** | 85Âµs | 120Âµs | 850Âµs | **7-10x** |
| **secp256k1 ç­¾å** | 12Âµs | 18Âµs | 120Âµs | **6-10x** |
| **ed25519 ç­¾å** | 8Âµs | 12Âµs | 95Âµs | **8-12x** |
| **é’±åŒ…åŒæ­¥** | 45ms | 65ms | 280ms | **4-6x** |
| **å†…å­˜å ç”¨** | 15MB | 22MB | 95MB | **4-6x** |

---

### ç¬¬ä¸‰æ–¹å®¡è®¡å·¥å…·

#### 1. cargo-audit (ä¾èµ–æ¼æ´æ£€æµ‹)

```bash
# å®‰è£…
cargo install cargo-audit

# æ£€æŸ¥å·²çŸ¥æ¼æ´
cargo audit

# è¾“å‡ºç¤ºä¾‹
Crate:     hyper
Version:   0.14.10
Warning:   RUSTSEC-2021-0079
Title:     Lenient parsing of Content-Length headers
Solution:  Upgrade to >= 0.14.11
```

#### 2. cargo-deny (è®¸å¯è¯ä¸å®‰å…¨ç­–ç•¥)

```bash
# å®‰è£…
cargo install cargo-deny

# åˆå§‹åŒ–é…ç½®
cargo deny init

# æ£€æŸ¥
cargo deny check
```

**deny.toml é…ç½®**:
```toml
[licenses]
unlicensed = "deny"
allow = ["MIT", "Apache-2.0", "BSD-3-Clause"]

[bans]
multiple-versions = "warn"

[advisories]
vulnerability = "deny"
unmaintained = "warn"
```

#### 3. cargo-geiger (unsafe ä»£ç æ£€æµ‹)

```bash
# å®‰è£…
cargo install cargo-geiger

# æ‰«æ unsafe
cargo geiger

# è¾“å‡ºç¤ºä¾‹
Metric output format: x/y
    x = unsafe code used by the build
    y = total unsafe code in the dependency tree

 Functions  Expressions  Impls  Traits  Methods  Dependency

 0/0        0/0          0/0    0/0     0/0      ironlink-dapp
 2/5        8/45         0/0    0/0     1/3      â”œâ”€â”€ ethers
 0/0        0/0          0/0    0/0     0/0      â””â”€â”€ tokio
```

---

### æŒç»­é›†æˆ (CI) å®‰å…¨æ£€æŸ¥

```yaml
# .github/workflows/security.yml
name: Security Audit

on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      
      - name: Run Clippy
        run: cargo clippy -- -D warnings
      
      - name: Run cargo-audit
        run: |
          cargo install cargo-audit
          cargo audit
      
      - name: Run cargo-deny
        run: |
          cargo install cargo-deny
          cargo deny check
      
      - name: Check for secrets
        run: |
          ! rg -i "password.*=.*['\"]|api.*key.*=.*['\"]" src/
      
      - name: Test coverage
        run: |
          cargo install cargo-tarpaulin
          cargo tarpaulin --fail-under 80
```

---

### ä¼ ç»Ÿæ–¹æ¡ˆçš„æŠ€æœ¯é—®é¢˜

---

## ğŸ“š å‚è€ƒèµ„æ–™

### æŠ€æœ¯æ ‡å‡†

- [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) - HD Wallets
- [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) - Mnemonic
- [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) - Multi-Account Hierarchy
- [EIP-155](https://eips.ethereum.org/EIPS/eip-155) - Simple replay attack protection
- [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) - Fee market

### Rustèµ„æº

- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust By Example](https://doc.rust-lang.org/rust-by-example/)
- [Rustonomicon](https://doc.rust-lang.org/nomicon/) - Unsafe Rust
- [Dioxus Docs](https://dioxuslabs.com/docs)

### å®‰å…¨èµ„æº

- [Zeroize Crate](https://docs.rs/zeroize/)
- [Secrecy Crate](https://docs.rs/secrecy/)
- [RustCrypto](https://github.com/RustCrypto)
- [iOS Security Guide](https://support.apple.com/guide/security/welcome/web)
- [Android Keystore](https://developer.android.com/training/articles/keystore)

---

## ğŸ“„ è®¸å¯è¯

MIT License - è¯¦è§ [LICENSE](LICENSE)

---

## ğŸ“ è”ç³»æ–¹å¼

- **GitHub**: [DarkCrab-Rust/IronLink-DApp](https://github.com/DarkCrab-Rust/IronLink-DApp)
- **Discord**: https://discord.gg/ironlink
- **Email**: dev@ironlink.io

---

<div align="center">

Made with ğŸ¦€ by the Iron Team

**Version**: 0.1.0-alpha  
**Last Updated**: November 13, 2025

</div>

